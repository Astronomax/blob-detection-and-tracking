#ifndef BLOB_TRACKER_BLOB_TRACKER_HPP
#define BLOB_TRACKER_BLOB_TRACKER_HPP

#include "../blob/blob.hpp"
#include "kalman_filter/kalman_filter.hpp"
#include "hungarian/hungarian.hpp"
#include <optional>
#include <unordered_set>

namespace blobs {
	/**
	 * \brief Устанавливает однозначное соответствие между объектами, предыдущего и текущего кадров.
	 */	
	class blob_tracker {
	public:
		constexpr static const size_t MAXN = hungarian::MAXN;	/*!< Максмальное количество объектов в одном кадре. */
		blob_tracker(bool use_prediction);

		/*! Статус объекта */
		enum class o_status {
			BORN, 	/*!< Объект впервые появился в кадре. */
			ALIVE, 	/*!< Объект уже существовал на предыдущем кадре, и был снова обнаружен на текущем кадре. */
			GHOST, 	/*!< Объект, был обнаружен несколько кадров назад, в какой-то момент но перестал обнаруживаться.
			 		 *  Теперь он либо перейдет в состояние ALIVE, если снова обнаружится, либо в состояние DIED,
			 		 *  если счетчик ttl успеет досчитать до 0. Т.е. пропавший объект исчечает не сразу,
			 		 *  а существует ещё ttl кадров подряд "по инерции" в надежде снова быть обнаруженным.
			 		 *  В состоянии GHOST текущее положение объекта предсказывается при помощи фильтра Калмана.
			 		 *  Это позволяет следить за объектами, даже если они кратковременно заслоняются другими объектами. */
			DIED 	/*!< На текущем кадре объект считается исчезнувшим навсегда. (ttl досчитал до 0).
					 * 	С этого момента id данного объекта освобождается. Если далее вы встретите объект с
			 		 *	таким же id, считайте, что это уже другой объект. */
		};

		struct object {
			o_status status;
			unsigned int id;
			blob<float> blob_data;
		};

		/**
		 * \brief Устанавливает однозначное соответствие между объектами, предыдущего и текущего кадров.
		 * 
		 * \details Присваивает объектам данного кадра id и статус. 
		 * Для установления соответствия track решает задачу "о назначениях": сопоставляет объекты так,
		 * чтобы минимизировать суммарное расстояние между объектами предыдущего кадра и соответствующими
		 * им объектами текущего кадра. При этом если trashold меньше бесконечности, будет учитываться
		 * дополнительное ограничение, что нельзя сопостявлять друг другу объекты, расстояние между которыми
		 * превосходит trashold. Это имеет смысл в ситуациях, когда мы в конкретном случае знаем, что
		 * объекты не могут за один кадр переместиться слишком далеко (на расстояние > trashold).
		 * Для решения задачи о назначениях track использует венгерский алгоритм.
		 * 
		 * \param blobs 			Объекты, обнаруженные детектором на текущем кадре.
		 * \param move_threshold 	Максимально допустимое перемещение объекта за один кадр.
		 * \param scale_threshold	Максимально допустимое изменение радиуса объекта за один кадр.
		 * \return 					Объекты, с присвоенными id и статусом.
		 */
		std::vector<object>
		track(const std::vector<blob<float>> &blobs, float move_threshold, float scale_threshold);

		/**
		 * \brief Устанавливает однозначное соответствие между объектами, предыдущего и текущего кадров.
		 * 
		 * \details Присваивает объектам данного кадра id и статус. 
		 * Для установления соответствия track решает задачу "о назначениях": сопоставляет объекты так,
		 * чтобы минимизировать суммарное расстояние между объектами предыдущего кадра и соответствующими
		 * им объектами текущего кадра. При этом если trashold меньше бесконечности, будет учитываться
		 * дополнительное ограничение, что нельзя сопостявлять друг другу объекты, расстояние между которыми
		 * превосходит trashold. Это имеет смысл в ситуациях, когда мы в конкретном случае знаем, что
		 * объекты не могут за один кадр переместиться слишком далеко (на расстояние > trashold).
		 * Для решения задачи о назначениях track использует венгерский алгоритм.
		 * 
		 * \param blobs 			Объекты, обнаруженные детектором на текущем кадре.
		 * \param tolerance_abs 	Максимально допустимое абсолютное отклонение от оптимальной суммы в угоду 
		 * уменьшению максимального перемещения.
		 * \param tolerance_rel 	Максимально допустимое относительное отклонение от оптимальной суммы в угоду 
		 * уменьшению максимального перемещения.		 
		 * \param scale_threshold	Максимально допустимое изменение радиуса объекта за один кадр.
		 * \return 					Объекты, с присвоенными id и статусом.
		 */
		std::vector<object>
		track_tolerant(const std::vector<blob<float>> &blobs, float tolerance_abs, float tolerance_rel, float scale_threshold);

	private:
		struct internal_state {
			internal_state();
			object obj{};
			kalman_filter kf;
			int ttl;
		};
	private:
		bool m_use_prediction;
		std::vector<internal_state> state;
		std::unordered_set<unsigned int> id_pool;
	};
}

#endif //BLOB_TRACKER_BLOB_TRACKER_HPP
